<!DOCTYPE html><html><head><meta charset="UTF-8"><meta content="width=device-width" name="viewport"><title>Natural Selection</title><style data-emotion="css-global">html{font-size:16px;line-height:1.5}body{background-color:pink;color:#00f;margin:0}*,::after,::before{box-sizing:border-box}</style><style data-emotion="css">.css-15currb{display:flex;height:100%}.css-1eqebxg{-webkit-box-flex:0;flex:0 0 10rem;color:pink;background-color:#00f}.css-1ff36h2{-webkit-box-flex:1;flex-grow:1}</style></head><body><div id="root"><div class="css-15currb"><div class="css-1eqebxg"><ul><li><a href="/docs">Introduction</a></li><li><a href="/docs/hooks">Hooks</a><ul><li><a href="/docs/hooks/useAccessibilityProps">useAccessibilityProps</a></li><li><a href="/docs/hooks/useControlledReducer">useControlledReducer</a></li><li><a href="/docs/hooks/useEnsuredId">useEnsuredId</a></li><li><a href="/docs/hooks/useScrollCaptor">useScrollCaptor</a></li><li><a href="/docs/hooks/useScrollToFocused">useScrollToFocused</a></li></ul></li><li>Components<ul><li><a href="/docs/components/Option">Option</a></li><li><a href="/docs/components/AccessibilityPropsProvider">AccessibilityPropsProvider</a></li></ul></li><li>Examples<ul><li><a href="/docs/examples/introduction">Introduction</a></li><li><a href="/docs/examples/single-select">Single select</a></li><li><a href="/docs/examples/multi-select">Multi select</a></li><li><a href="/docs/examples/date-picker">Date picker</a></li></ul></li></ul></div><div class="css-1ff36h2"><h1><code>useControlledReducer</code></h1><p>React's <a href="https://reactjs.org/docs/hooks-reference.html#usereducer">built-in <code>useReducer</code> hook</a> is a great fit for selection components, which tend to have interdependent state, and which often have similar-yet-different variants that share core logic. <code>useControlledReducer</code> is a wrapper around <code>useReducer</code> that allows you to control pieces of state from outside the component.</p><h1>Arguments</h1><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>reducer</code></td><td><code>Reducer&lt;State, Action></code></td><td>The reducer function.</td></tr><tr><td><code>initialState</code></td><td><code>State</code></td><td>The initial state.</td></tr><tr><td><code>props</code></td><td><code>Partial&lt;State></code></td><td>A subset of state that will override the corresponding state properties. If the reducer receives an action that would modify these properties, those changes will be overridden; if the reducer receives an action that <em>only</em> updates those properties, the hook will bail out of the state update and won't trigger a render. This argument should be memoized.</td></tr><tr><td>onStateChange</td><td><code>(state: State, action: Action, prevState: State) => void</code></td><td>A callback that will be invoked whenever the reducer modifies the state. It will receive the current state, the action that caused the state update, and the previous state, in that order. This is useful if you're using the "controlled props" pattern and need to update external state in response to dispatched actions.</td></tr></tbody></table><h1>Return value</h1><table><thead><tr><th>Property</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td></td><td><code>[State, Dispatch]</code></td><td>Just like vanilla <code>useReducer</code>.</td></tr></tbody></table></div></div></div><script src="/app.js" type="text/javascript"></script></body></html>